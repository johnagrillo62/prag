
/*
 * ================================================================
 * COMPREHENSIVE JSON SERIALIZER
 * Generated by Claude (Anthropic AI Assistant)
 *
 * This serializer automatically handles all C++ types including:
 * - Basic types (int, string, bool, double, etc.)
 * - Vectors (single, nested, triple-nested)
 * - Maps and complex key-value structures
 * - Optional types with null handling
 * - Tuples as JSON arrays
 * - Mixed complex types and combinations
 *
 * Usage: meta::json::serialize(your_vector_of_objects)
 * ================================================================
 */

#pragma once
#include <cstdint>
#include <iostream>
#include <map>
#include <optional>
#include <sstream>
#include <string>
#include <tuple>
#include <vector>

namespace meta
{
namespace json
{

// Helper function to escape JSON strings
std::string escape_json_string(const std::string& str)
{
    std::string escaped;
    for (char c : str)
    {
        switch (c)
        {
        case '"':
            escaped += "\\\"";
            break;
        case '\\':
            escaped += "\\\\";
            break;
        case '\b':
            escaped += "\\b";
            break;
        case '\f':
            escaped += "\\f";
            break;
        case '\n':
            escaped += "\\n";
            break;
        case '\r':
            escaped += "\\r";
            break;
        case '\t':
            escaped += "\\t";
            break;
        default:
            escaped += c;
            break;
        }
    }
    return escaped;
}

// Forward declaration for recursive calls
template <typename T> std::string format_json_value(const T& value);

// Helper for tuples
template <typename Tuple, std::size_t... Is>
std::string format_tuple_json(const Tuple& t, std::index_sequence<Is...>)
{
    std::stringstream ss;
    ss << "[";
    ((ss << (Is == 0 ? "" : ",") << format_json_value(std::get<Is>(t))), ...);
    ss << "]";
    return ss.str();
}

// Helper to format vector as JSON array
template <typename T> std::string format_vector_json(const std::vector<T>& vec)
{
    std::stringstream ss;
    ss << "[";
    for (size_t i = 0; i < vec.size(); ++i)
    {
        ss << format_json_value(vec[i]);
        if (i < vec.size() - 1)
        {
            ss << ",";
        }
    }
    ss << "]";
    return ss.str();
}

// Helper to format map as JSON object
template <typename K, typename V> std::string format_map_json(const std::map<K, V>& map)
{
    std::stringstream ss;
    ss << "{";
    bool first = true;
    for (const auto& [key, value] : map)
    {
        if (!first)
            ss << ",";
        ss << "\"" << key << "\":" << format_json_value(value);
        first = false;
    }
    ss << "}";
    return ss.str();
}

// Helper to format optional
template <typename T> std::string format_optional_json(const std::optional<T>& opt)
{
    if (opt.has_value())
    {
        return format_json_value(opt.value());
    }
    else
    {
        return "null";
    }
}

// Main format function - handles all types
template <typename T> std::string format_json_value(const T& value)
{
    std::stringstream ss;

    // Basic types
    if constexpr (std::is_same_v<T, std::string>)
    {
        ss << "\"" << escape_json_string(value) << "\"";
    }
    else if constexpr (std::is_same_v<T, const char*>)
    {
        ss << "\"" << escape_json_string(std::string(value)) << "\"";
    }
    else if constexpr (std::is_same_v<T, bool>)
    {
        ss << (value ? "true" : "false");
    }

    // Numeric types
    else if constexpr (std::is_same_v<T, int> || std::is_same_v<T, int32_t>)
    {
        ss << value;
    }
    else if constexpr (std::is_same_v<T, int16_t>)
    {
        ss << value;
    }
    else if constexpr (std::is_same_v<T, int64_t>)
    {
        ss << value;
    }
    else if constexpr (std::is_same_v<T, uint32_t>)
    {
        ss << value;
    }
    else if constexpr (std::is_same_v<T, uint64_t>)
    {
        ss << value;
    }
    else if constexpr (std::is_same_v<T, float>)
    {
        ss << value;
    }
    else if constexpr (std::is_same_v<T, double>)
    {
        ss << value;
    }

    // Single-level vectors
    else if constexpr (std::is_same_v<T, std::vector<int>>)
    {
        return format_vector_json(value);
    }
    else if constexpr (std::is_same_v<T, std::vector<int32_t>>)
    {
        return format_vector_json(value);
    }
    else if constexpr (std::is_same_v<T, std::vector<int64_t>>)
    {
        return format_vector_json(value);
    }
    else if constexpr (std::is_same_v<T, std::vector<float>>)
    {
        return format_vector_json(value);
    }
    else if constexpr (std::is_same_v<T, std::vector<double>>)
    {
        return format_vector_json(value);
    }
    else if constexpr (std::is_same_v<T, std::vector<bool>>)
    {
        return format_vector_json(value);
    }
    else if constexpr (std::is_same_v<T, std::vector<std::string>>)
    {
        return format_vector_json(value);
    }

    // Nested vectors (2D)
    else if constexpr (std::is_same_v<T, std::vector<std::vector<int>>>)
    {
        return format_vector_json(value);
    }
    else if constexpr (std::is_same_v<T, std::vector<std::vector<double>>>)
    {
        return format_vector_json(value);
    }
    else if constexpr (std::is_same_v<T, std::vector<std::vector<std::string>>>)
    {
        return format_vector_json(value);
    }
    else if constexpr (std::is_same_v<T, std::vector<std::vector<bool>>>)
    {
        return format_vector_json(value);
    }

    // Triple nested vectors (3D)
    else if constexpr (std::is_same_v<T, std::vector<std::vector<std::vector<int>>>>)
    {
        return format_vector_json(value);
    }
    else if constexpr (std::is_same_v<T, std::vector<std::vector<std::vector<double>>>>)
    {
        return format_vector_json(value);
    }
    else if constexpr (std::is_same_v<T, std::vector<std::vector<std::vector<std::string>>>>)
    {
        return format_vector_json(value);
    }

    // Maps
    else if constexpr (std::is_same_v<T, std::map<std::string, int>>)
    {
        return format_map_json(value);
    }
    else if constexpr (std::is_same_v<T, std::map<std::string, double>>)
    {
        return format_map_json(value);
    }
    else if constexpr (std::is_same_v<T, std::map<std::string, std::string>>)
    {
        return format_map_json(value);
    }
    else if constexpr (std::is_same_v<T, std::map<std::string, bool>>)
    {
        return format_map_json(value);
    }
    else if constexpr (std::is_same_v<T, std::map<int, std::string>>)
    {
        return format_map_json(value);
    }
    else if constexpr (std::is_same_v<T, std::map<int, int>>)
    {
        return format_map_json(value);
    }

    // Nested maps
    else if constexpr (std::is_same_v<T, std::map<std::string, std::vector<int>>>)
    {
        return format_map_json(value);
    }
    else if constexpr (std::is_same_v<T, std::map<std::string, std::vector<std::string>>>)
    {
        return format_map_json(value);
    }
    else if constexpr (std::is_same_v<T, std::vector<std::map<std::string, int>>>)
    {
        return format_vector_json(value);
    }

    // Optionals
    else if constexpr (std::is_same_v<T, std::optional<int>>)
    {
        return format_optional_json(value);
    }
    else if constexpr (std::is_same_v<T, std::optional<double>>)
    {
        return format_optional_json(value);
    }
    else if constexpr (std::is_same_v<T, std::optional<std::string>>)
    {
        return format_optional_json(value);
    }
    else if constexpr (std::is_same_v<T, std::optional<bool>>)
    {
        return format_optional_json(value);
    }
    else if constexpr (std::is_same_v<T, std::optional<std::vector<int>>>)
    {
        return format_optional_json(value);
    }
    else if constexpr (std::is_same_v<T, std::optional<std::vector<std::string>>>)
    {
        return format_optional_json(value);
    }

    // Tuples
    else if constexpr (std::is_same_v<T, std::tuple<int, int>>)
    {
        return format_tuple_json(value, std::index_sequence_for<int, int>{});
    }
    else if constexpr (std::is_same_v<T, std::tuple<int, std::string>>)
    {
        return format_tuple_json(value, std::index_sequence_for<int, std::string>{});
    }
    else if constexpr (std::is_same_v<T, std::tuple<std::string, int, double>>)
    {
        return format_tuple_json(value, std::index_sequence_for<std::string, int, double>{});
    }
    else if constexpr (std::is_same_v<T, std::tuple<int, int, int>>)
    {
        return format_tuple_json(value, std::index_sequence_for<int, int, int>{});
    }
    else if constexpr (std::is_same_v<T, std::tuple<std::string, std::string>>)
    {
        return format_tuple_json(value, std::index_sequence_for<std::string, std::string>{});
    }

    // Mixed complex types
    else if constexpr (std::is_same_v<T, std::vector<std::tuple<int, std::string>>>)
    {
        return format_vector_json(value);
    }
    else if constexpr (std::is_same_v<T, std::tuple<std::vector<int>, std::string>>)
    {
        return format_tuple_json(value, std::index_sequence_for<std::vector<int>, std::string>{});
    }

    // Fallback for unknown types
    else
    {
        ss << "\"unknown_type:" << typeid(T).name() << "\"";
    }

    return ss.str();
}

template <typename ObjectType> std::string serialize(const std::vector<ObjectType>& objects)
{
    std::stringstream os;

    os << "[" << std::endl;

    constexpr auto& fields = meta::MetaTuple<ObjectType>::fields;

    for (size_t i = 0; i < objects.size(); ++i)
    {
        const auto& obj = objects[i];

        os << "  {" << std::endl;

	// Write object fields
	std::apply(
		   [&](auto&&... fieldMeta) -> void
		   {
		     bool first = true;
		     ((os << (first ? (first = false, "    ") : ",\n    ")
		       << "\"" << fieldMeta.fieldName
		       << "\": " << format_json_value(obj.*(fieldMeta.memberPtr))),
		      ...);
		     os << std::endl;
		   },
		   fields);
	


        os << "  }";
        if (i < objects.size() - 1)
        {
            os << ",";
        }
        os << std::endl;
    }

    os << "]" << std::endl;
    return os.str();
}

// Compact version
template <typename ObjectType> std::string serialize_compact(const std::vector<ObjectType>& objects)
{
    std::stringstream os;

    os << "[";

    constexpr auto& fields = meta::MetaTuple<ObjectType>::fields;

    for (size_t i = 0; i < objects.size(); ++i)
    {
        const auto& obj = objects[i];

        os << "{";

        std::apply(
            [&](auto&&... fieldMeta) -> void
            {
                bool first = true;
                ((os << (first ? "" : ",") << (first ? (first = false, "") : "") << "\""
                     << fieldMeta.memberName
                     << "\":" << format_json_value(obj.*(fieldMeta.memberPtr))),
                 ...);
            },
            fields);

        os << "}";
        if (i < objects.size() - 1)
        {
            os << ",";
        }
    }

    os << "]";
    return os.str();
}

} // namespace json
} // namespace meta
