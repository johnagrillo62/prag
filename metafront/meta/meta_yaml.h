/*
 * ================================================================
 * COMPREHENSIVE YAML SERIALIZER
 * Generated by Claude (Anthropic AI Assistant)
 *
 * This serializer automatically handles all C++ types including:
 * - Basic types (int, string, bool, double, etc.)
 * - Vectors (single, nested, triple-nested)
 * - Maps and complex key-value structures
 * - Optional types with null handling
 * - Tuples as YAML arrays
 * - Mixed complex types and combinations
 *
 * Usage: meta::yaml::serialize(your_vector_of_objects)
 * ================================================================
 */

#pragma once
#include <algorithm>
#include <cstdint>
#include <iostream>
#include <map>
#include <optional>
#include <sstream>
#include <string>
#include <tuple>
#include <vector>

namespace meta
{
namespace yaml
{

// Helper function to escape YAML strings
std::string escape_yaml_string(const std::string& str)
{
    // Check if string needs quoting
    bool needs_quotes = false;

    // YAML special cases that need quoting
    if (str.empty() || str == "true" || str == "false" || str == "yes" || str == "no" ||
        str == "null" || str == "~" || std::isdigit(str[0]) || str[0] == '-' || str[0] == '+' ||
        str.find(':') != std::string::npos || str.find('#') != std::string::npos ||
        str.find('\n') != std::string::npos || str.find('\r') != std::string::npos ||
        str.find('\t') != std::string::npos || str.find('"') != std::string::npos ||
        str.find('\'') != std::string::npos || str.find('[') != std::string::npos ||
        str.find(']') != std::string::npos || str.find('{') != std::string::npos ||
        str.find('}') != std::string::npos || str[0] == ' ' || str.back() == ' ')
    {
        needs_quotes = true;
    }

    if (!needs_quotes)
    {
        return str;
    }

    // Use double quotes and escape
    std::string escaped = "\"";
    for (char c : str)
    {
        switch (c)
        {
        case '"':
            escaped += "\\\"";
            break;
        case '\\':
            escaped += "\\\\";
            break;
        case '\b':
            escaped += "\\b";
            break;
        case '\f':
            escaped += "\\f";
            break;
        case '\n':
            escaped += "\\n";
            break;
        case '\r':
            escaped += "\\r";
            break;
        case '\t':
            escaped += "\\t";
            break;
        default:
            escaped += c;
            break;
        }
    }
    escaped += "\"";
    return escaped;
}

// Forward declaration for recursive calls
template <typename T> std::string format_yaml_value(const T& value, int indent_level = 0);

// Helper to create indentation
std::string get_indent(int level)
{
    return std::string(level * 2, ' ');
}

// Helper for tuples
template <typename Tuple, std::size_t... Is>
std::string format_tuple_yaml(const Tuple& t, std::index_sequence<Is...>, int indent_level = 0)
{
    std::stringstream ss;
    ss << "\n";
    ((ss << get_indent(indent_level + 1) << "- "
         << format_yaml_value(std::get<Is>(t), indent_level + 1) << "\n"),
     ...);
    return ss.str();
}

// Helper to format vector as YAML array
template <typename T>
std::string format_vector_yaml(const std::vector<T>& vec, int indent_level = 0)
{
    if (vec.empty())
    {
        return "[]";
    }

    std::stringstream ss;

    // Check if it's a simple type that can be inline
    bool is_simple =
        std::is_arithmetic_v<T> || std::is_same_v<T, std::string> || std::is_same_v<T, bool>;

    if (is_simple && vec.size() <= 5)
    {
        // Inline format for small simple arrays
        ss << "[";
        for (size_t i = 0; i < vec.size(); ++i)
        {
            ss << format_yaml_value(vec[i], 0);
            if (i < vec.size() - 1)
            {
                ss << ", ";
            }
        }
        ss << "]";
    }
    else
    {
        // Block format
        ss << "\n";
        for (const auto& item : vec)
        {
            ss << get_indent(indent_level + 1) << "- ";
            std::string item_str = format_yaml_value(item, indent_level + 1);
            if (item_str.front() == '\n')
            {
                // Multi-line value, indent properly
                ss << item_str;
            }
            else
            {
                ss << item_str << "\n";
            }
        }
    }
    return ss.str();
}

// Helper to format map as YAML object
template <typename K, typename V>
std::string format_map_yaml(const std::map<K, V>& map, int indent_level = 0)
{
    if (map.empty())
    {
        return "{}";
    }

    std::stringstream ss;
    ss << "\n";

    for (const auto& [key, value] : map)
    {
        ss << get_indent(indent_level + 1) << key << ": ";
        std::string value_str = format_yaml_value(value, indent_level + 1);
        if (value_str.front() == '\n')
        {
            // Multi-line value
            ss << value_str;
        }
        else
        {
            ss << value_str << "\n";
        }
    }
    return ss.str();
}

// Helper to format optional
template <typename T>
std::string format_optional_yaml(const std::optional<T>& opt, int indent_level = 0)
{
    if (opt.has_value())
    {
        return format_yaml_value(opt.value(), indent_level);
    }
    else
    {
        return "null";
    }
}

// Main format function - handles all types
template <typename T> std::string format_yaml_value(const T& value, int indent_level)
{
    std::stringstream ss;

    // Basic types
    if constexpr (std::is_same_v<T, std::string>)
    {
        return escape_yaml_string(value);
    }
    else if constexpr (std::is_same_v<T, const char*>)
    {
        return escape_yaml_string(std::string(value));
    }
    else if constexpr (std::is_same_v<T, bool>)
    {
        return value ? "true" : "false";
    }

    // Numeric types
    else if constexpr (std::is_same_v<T, int> || std::is_same_v<T, int32_t>)
    {
        return std::to_string(value);
    }
    else if constexpr (std::is_same_v<T, int16_t>)
    {
        return std::to_string(value);
    }
    else if constexpr (std::is_same_v<T, int64_t>)
    {
        return std::to_string(value);
    }
    else if constexpr (std::is_same_v<T, uint32_t>)
    {
        return std::to_string(value);
    }
    else if constexpr (std::is_same_v<T, uint64_t>)
    {
        return std::to_string(value);
    }
    else if constexpr (std::is_same_v<T, float>)
    {
        return std::to_string(value);
    }
    else if constexpr (std::is_same_v<T, double>)
    {
        return std::to_string(value);
    }

    // Single-level vectors
    else if constexpr (std::is_same_v<T, std::vector<int>>)
    {
        return format_vector_yaml(value, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::vector<int32_t>>)
    {
        return format_vector_yaml(value, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::vector<int64_t>>)
    {
        return format_vector_yaml(value, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::vector<float>>)
    {
        return format_vector_yaml(value, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::vector<double>>)
    {
        return format_vector_yaml(value, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::vector<bool>>)
    {
        return format_vector_yaml(value, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::vector<std::string>>)
    {
        return format_vector_yaml(value, indent_level);
    }

    // Nested vectors (2D)
    else if constexpr (std::is_same_v<T, std::vector<std::vector<int>>>)
    {
        return format_vector_yaml(value, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::vector<std::vector<double>>>)
    {
        return format_vector_yaml(value, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::vector<std::vector<std::string>>>)
    {
        return format_vector_yaml(value, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::vector<std::vector<bool>>>)
    {
        return format_vector_yaml(value, indent_level);
    }

    // Triple nested vectors (3D)
    else if constexpr (std::is_same_v<T, std::vector<std::vector<std::vector<int>>>>)
    {
        return format_vector_yaml(value, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::vector<std::vector<std::vector<double>>>>)
    {
        return format_vector_yaml(value, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::vector<std::vector<std::vector<std::string>>>>)
    {
        return format_vector_yaml(value, indent_level);
    }

    // Maps - Basic types
    else if constexpr (std::is_same_v<T, std::map<std::string, int>>)
    {
        return format_map_yaml(value, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::map<std::string, double>>)
    {
        return format_map_yaml(value, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::map<std::string, std::string>>)
    {
        return format_map_yaml(value, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::map<std::string, bool>>)
    {
        return format_map_yaml(value, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::map<int, std::string>>)
    {
        return format_map_yaml(value, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::map<int, int>>)
    {
        return format_map_yaml(value, indent_level);
    }

    // Nested maps - FIXED SECTION WITH MISSING TYPES
    else if constexpr (std::is_same_v<T, std::map<std::string, std::vector<int>>>)
    {
        return format_map_yaml(value, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::map<std::string, std::vector<double>>>)
    { // ADDED FOR measurements
        return format_map_yaml(value, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::map<std::string, std::vector<std::string>>>)
    {
        return format_map_yaml(value, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::map<std::string, std::vector<bool>>>)
    { // ADDED
        return format_map_yaml(value, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::vector<std::map<std::string, int>>>)
    {
        return format_vector_yaml(value, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::vector<std::map<std::string, bool>>>)
    { // ADDED FOR flags
        return format_vector_yaml(value, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::vector<std::map<std::string, std::string>>>)
    { // ADDED
        return format_vector_yaml(value, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::vector<std::map<std::string, double>>>)
    { // ADDED
        return format_vector_yaml(value, indent_level);
    }

    // Optionals
    else if constexpr (std::is_same_v<T, std::optional<int>>)
    {
        return format_optional_yaml(value, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::optional<double>>)
    {
        return format_optional_yaml(value, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::optional<std::string>>)
    {
        return format_optional_yaml(value, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::optional<bool>>)
    {
        return format_optional_yaml(value, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::optional<std::vector<int>>>)
    {
        return format_optional_yaml(value, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::optional<std::vector<std::string>>>)
    {
        return format_optional_yaml(value, indent_level);
    }

    // Tuples
    else if constexpr (std::is_same_v<T, std::tuple<int, int>>)
    {
        return format_tuple_yaml(value, std::index_sequence_for<int, int>{}, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::tuple<int, std::string>>)
    {
        return format_tuple_yaml(value, std::index_sequence_for<int, std::string>{}, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::tuple<std::string, int, double>>)
    {
        return format_tuple_yaml(
            value, std::index_sequence_for<std::string, int, double>{}, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::tuple<int, int, int>>)
    {
        return format_tuple_yaml(value, std::index_sequence_for<int, int, int>{}, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::tuple<std::string, std::string>>)
    {
        return format_tuple_yaml(
            value, std::index_sequence_for<std::string, std::string>{}, indent_level);
    }

    // Mixed complex types
    else if constexpr (std::is_same_v<T, std::vector<std::tuple<int, std::string>>>)
    {
        return format_vector_yaml(value, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::tuple<std::vector<int>, std::string>>)
    {
        return format_tuple_yaml(
            value, std::index_sequence_for<std::vector<int>, std::string>{}, indent_level);
    }

    // Fallback for unknown types
    else
    {
        return std::string("unknown_type:") + typeid(T).name();
    }
}

// Main serialize function - pretty formatted
template <typename ObjectType> std::string serialize(const std::vector<ObjectType>& objects)
{
    if (objects.empty())
    {
        return "---\n[]\n";
    }

    std::stringstream os;
    os << "---\n";

    constexpr auto& fields = meta::MetaTuple<ObjectType>::fields;

    for (size_t i = 0; i < objects.size(); ++i)
    {
        const auto& obj = objects[i];

        os << "- ";

        // Write object fields
        std::apply(
            [&](auto&&... fieldMeta) -> void
            {
                bool first = true;
                ((first ? (os << fieldMeta.memberName << ": ", first = false)
                        : (os << "  " << fieldMeta.memberName << ": "),
                  [&]()
                  {
                      std::string value_str = format_yaml_value(obj.*(fieldMeta.memberPtr), 1);
                      if (value_str.front() == '\n')
                      {
                          os << value_str;
                      }
                      else
                      {
                          os << value_str << "\n";
                      }
                  }()),
                 ...);
            },
            fields);
    }

    return os.str();
}

// Compact version - flow style where appropriate
template <typename ObjectType> std::string serialize_compact(const std::vector<ObjectType>& objects)
{
    if (objects.empty())
    {
        return "---\n[]";
    }

    std::stringstream os;
    os << "---\n";

    constexpr auto& fields = meta::MetaTuple<ObjectType>::fields;

    for (size_t i = 0; i < objects.size(); ++i)
    {
        const auto& obj = objects[i];

        os << "- {";

        std::apply(
            [&](auto&&... fieldMeta) -> void
            {
                bool first = true;
                ((os << (first ? "" : ", ") << (first ? (first = false, "") : "")
                     << fieldMeta.memberName << ": "
                     << format_yaml_value(obj.*(fieldMeta.memberPtr), 0)),
                 ...);
            },
            fields);

        os << "}";
        if (i < objects.size() - 1)
        {
            os << "\n";
        }
    }

    return os.str();
}

// Alternative serialize function with custom document separator and comments
template <typename ObjectType>
std::string serialize_with_comments(const std::vector<ObjectType>& objects,
                                    const std::string& comment = "")
{
    if (objects.empty())
    {
        return "---\n# Empty collection\n[]\n";
    }

    std::stringstream os;
    os << "---\n";

    if (!comment.empty())
    {
        os << "# " << comment << "\n";
    }

    os << "# Generated YAML with " << objects.size() << " objects\n";

    constexpr auto& fields = meta::MetaTuple<ObjectType>::fields;

    for (size_t i = 0; i < objects.size(); ++i)
    {
        const auto& obj = objects[i];

        if (i == 0)
        {
            os << "# Object fields: ";
            std::apply(
                [&](auto&&... fieldMeta) -> void
                {
                    bool first = true;
                    ((os << (first ? "" : ", ") << (first ? (first = false, "") : "")
                         << fieldMeta.memberName),
                     ...);
                },
                fields);
            os << "\n";
        }

        os << "- ";

        std::apply(
            [&](auto&&... fieldMeta) -> void
            {
                bool first = true;
                ((first ? (os << fieldMeta.memberName << ": ", first = false)
                        : (os << "  " << fieldMeta.memberName << ": "),
                  [&]()
                  {
                      std::string value_str = format_yaml_value(obj.*(fieldMeta.memberPtr), 1);
                      if (value_str.front() == '\n')
                      {
                          os << value_str;
                      }
                      else
                      {
                          os << value_str << "\n";
                      }
                  }()),
                 ...);
            },
            fields);
    }

    return os.str();
}

// Utility function to serialize single object (not in array)
template <typename ObjectType> std::string serialize_single(const ObjectType& obj)
{
    std::stringstream os;
    os << "---\n";

    constexpr auto& fields = meta::MetaTuple<ObjectType>::fields;

    std::apply(
        [&](auto&&... fieldMeta) -> void
        {
            ((os << fieldMeta.fieldName << ": " <<
              [&]()
              {
                  std::string value_str = format_yaml_value(obj.*(fieldMeta.memberPtr), 0);
                  return (value_str.front() == '\n') ? value_str : value_str + "\n";
              }()),
             ...);
        },
        fields);

    return os.str();
}

} // namespace yaml
} // namespace meta
