/*
 * ================================================================
 * COMPREHENSIVE XML SERIALIZER
 * Generated by Claude (Anthropic AI Assistant)
 *
 * This serializer automatically handles all C++ types including:
 * - Basic types (int, string, bool, double, etc.)
 * - Vectors (single, nested, triple-nested)
 * - Maps and complex key-value structures
 * - Optional types with null handling
 * - Tuples as XML arrays
 * - Mixed complex types and combinations
 *
 * Usage: meta::xml::serialize(your_vector_of_objects)
 * ================================================================
 */

#pragma once
#include <algorithm>
#include <cstdint>
#include <iostream>
#include <map>
#include <optional>
#include <sstream>
#include <string>
#include <tuple>
#include <vector>

namespace meta
{
namespace xml
{

// Helper function to escape XML strings
std::string escape_xml_string(const std::string& str)
{
    std::string escaped;
    escaped.reserve(str.length());

    for (char c : str)
    {
        switch (c)
        {
        case '<':
            escaped += "&lt;";
            break;
        case '>':
            escaped += "&gt;";
            break;
        case '&':
            escaped += "&amp;";
            break;
        case '"':
            escaped += "&quot;";
            break;
        case '\'':
            escaped += "&apos;";
            break;
        case '\n':
            escaped += "&#10;";
            break;
        case '\r':
            escaped += "&#13;";
            break;
        case '\t':
            escaped += "&#9;";
            break;
        default:
            if (static_cast<unsigned char>(c) < 32)
            {
                // Control characters
                escaped += "&#" + std::to_string(static_cast<int>(c)) + ";";
            }
            else
            {
                escaped += c;
            }
            break;
        }
    }
    return escaped;
}

// Forward declaration for recursive calls
template <typename T>
std::string format_xml_value(const T& value,
                             const std::string& tag_name = "item",
                             int indent_level = 0);

// Helper to create indentation
std::string get_indent(int level)
{
    return std::string(level * 2, ' ');
}

// Helper for tuples
template <typename Tuple, std::size_t... Is>
std::string format_tuple_xml(const Tuple& t,
                             std::index_sequence<Is...>,
                             const std::string& tag_name = "tuple",
                             int indent_level = 0)
{
    std::stringstream ss;
    std::string ind = get_indent(indent_level);

    ss << ind << "<" << tag_name << ">\n";
    ((ss << format_xml_value(std::get<Is>(t), "element_" + std::to_string(Is), indent_level + 1)
         << "\n"),
     ...);
    ss << ind << "</" << tag_name << ">";

    return ss.str();
}

// Helper to format vector as XML array
template <typename T>
std::string format_vector_xml(const std::vector<T>& vec,
                              const std::string& tag_name = "array",
                              int indent_level = 0)
{
    std::string ind = get_indent(indent_level);

    if (vec.empty())
    {
        return ind + "<" + tag_name + " />";
    }

    std::stringstream ss;
    ss << ind << "<" << tag_name << ">\n";

    for (const auto& item : vec)
    {
        ss << format_xml_value(item, "item", indent_level + 1) << "\n";
    }

    ss << ind << "</" << tag_name << ">";
    return ss.str();
}

// Helper to format map as XML object
template <typename K, typename V>
std::string format_map_xml(const std::map<K, V>& map,
                           const std::string& tag_name = "map",
                           int indent_level = 0)
{
    std::string ind = get_indent(indent_level);

    if (map.empty())
    {
        return ind + "<" + tag_name + " />";
    }

    std::stringstream ss;
    ss << ind << "<" << tag_name << ">\n";

    for (const auto& [key, value] : map)
    {
        std::string key_str;
        if constexpr (std::is_same_v<K, std::string>)
        {
            key_str = key;
        }
        else
        {
            key_str = std::to_string(key);
        }

        // Sanitize key for XML tag name
        std::string safe_key = key_str;
        std::replace_if(
            safe_key.begin(),
            safe_key.end(),
            [](char c) { return !std::isalnum(c) && c != '_' && c != '-'; },
            '_');
        if (std::isdigit(safe_key[0]))
        {
            safe_key = "key_" + safe_key;
        }

        ss << format_xml_value(value, safe_key, indent_level + 1) << "\n";
    }

    ss << ind << "</" << tag_name << ">";
    return ss.str();
}

// Helper to format optional
template <typename T>
std::string format_optional_xml(const std::optional<T>& opt,
                                const std::string& tag_name = "optional",
                                int indent_level = 0)
{
    std::string ind = get_indent(indent_level);

    if (opt.has_value())
    {
        return format_xml_value(opt.value(), tag_name, indent_level);
    }
    else
    {
        return ind + "<" + tag_name + " null=\"true\" />";
    }
}

// Main format function - handles all types
template <typename T>
std::string format_xml_value(const T& value, const std::string& tag_name, int indent_level)
{
    std::string ind = get_indent(indent_level);
    std::stringstream ss;

    // Basic types
    if constexpr (std::is_same_v<T, std::string>)
    {
        ss << ind << "<" << tag_name << ">" << escape_xml_string(value) << "</" << tag_name << ">";
    }
    else if constexpr (std::is_same_v<T, const char*>)
    {
        ss << ind << "<" << tag_name << ">" << escape_xml_string(std::string(value)) << "</"
           << tag_name << ">";
    }
    else if constexpr (std::is_same_v<T, bool>)
    {
        ss << ind << "<" << tag_name << ">" << (value ? "true" : "false") << "</" << tag_name
           << ">";
    }

    // Numeric types
    else if constexpr (std::is_same_v<T, int> || std::is_same_v<T, int32_t>)
    {
        ss << ind << "<" << tag_name << ">" << value << "</" << tag_name << ">";
    }
    else if constexpr (std::is_same_v<T, int16_t>)
    {
        ss << ind << "<" << tag_name << ">" << value << "</" << tag_name << ">";
    }
    else if constexpr (std::is_same_v<T, int64_t>)
    {
        ss << ind << "<" << tag_name << ">" << value << "</" << tag_name << ">";
    }
    else if constexpr (std::is_same_v<T, uint32_t>)
    {
        ss << ind << "<" << tag_name << ">" << value << "</" << tag_name << ">";
    }
    else if constexpr (std::is_same_v<T, uint64_t>)
    {
        ss << ind << "<" << tag_name << ">" << value << "</" << tag_name << ">";
    }
    else if constexpr (std::is_same_v<T, float>)
    {
        ss << ind << "<" << tag_name << ">" << value << "</" << tag_name << ">";
    }
    else if constexpr (std::is_same_v<T, double>)
    {
        ss << ind << "<" << tag_name << ">" << value << "</" << tag_name << ">";
    }

    // Single-level vectors
    else if constexpr (std::is_same_v<T, std::vector<int>>)
    {
        return format_vector_xml(value, tag_name, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::vector<int32_t>>)
    {
        return format_vector_xml(value, tag_name, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::vector<int64_t>>)
    {
        return format_vector_xml(value, tag_name, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::vector<float>>)
    {
        return format_vector_xml(value, tag_name, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::vector<double>>)
    {
        return format_vector_xml(value, tag_name, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::vector<bool>>)
    {
        return format_vector_xml(value, tag_name, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::vector<std::string>>)
    {
        return format_vector_xml(value, tag_name, indent_level);
    }

    // Nested vectors (2D)
    else if constexpr (std::is_same_v<T, std::vector<std::vector<int>>>)
    {
        return format_vector_xml(value, tag_name, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::vector<std::vector<double>>>)
    {
        return format_vector_xml(value, tag_name, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::vector<std::vector<std::string>>>)
    {
        return format_vector_xml(value, tag_name, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::vector<std::vector<bool>>>)
    {
        return format_vector_xml(value, tag_name, indent_level);
    }

    // Triple nested vectors (3D)
    else if constexpr (std::is_same_v<T, std::vector<std::vector<std::vector<int>>>>)
    {
        return format_vector_xml(value, tag_name, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::vector<std::vector<std::vector<double>>>>)
    {
        return format_vector_xml(value, tag_name, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::vector<std::vector<std::vector<std::string>>>>)
    {
        return format_vector_xml(value, tag_name, indent_level);
    }

    // Maps - Basic types
    else if constexpr (std::is_same_v<T, std::map<std::string, int>>)
    {
        return format_map_xml(value, tag_name, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::map<std::string, double>>)
    {
        return format_map_xml(value, tag_name, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::map<std::string, std::string>>)
    {
        return format_map_xml(value, tag_name, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::map<std::string, bool>>)
    {
        return format_map_xml(value, tag_name, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::map<int, std::string>>)
    {
        return format_map_xml(value, tag_name, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::map<int, int>>)
    {
        return format_map_xml(value, tag_name, indent_level);
    }

    // Nested maps - Including the complex types from AdvancedData
    else if constexpr (std::is_same_v<T, std::map<std::string, std::vector<int>>>)
    {
        return format_map_xml(value, tag_name, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::map<std::string, std::vector<double>>>)
    {
        return format_map_xml(value, tag_name, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::map<std::string, std::vector<std::string>>>)
    {
        return format_map_xml(value, tag_name, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::map<std::string, std::vector<bool>>>)
    {
        return format_map_xml(value, tag_name, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::vector<std::map<std::string, int>>>)
    {
        return format_vector_xml(value, tag_name, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::vector<std::map<std::string, bool>>>)
    {
        return format_vector_xml(value, tag_name, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::vector<std::map<std::string, std::string>>>)
    {
        return format_vector_xml(value, tag_name, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::vector<std::map<std::string, double>>>)
    {
        return format_vector_xml(value, tag_name, indent_level);
    }

    // Optionals
    else if constexpr (std::is_same_v<T, std::optional<int>>)
    {
        return format_optional_xml(value, tag_name, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::optional<double>>)
    {
        return format_optional_xml(value, tag_name, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::optional<std::string>>)
    {
        return format_optional_xml(value, tag_name, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::optional<bool>>)
    {
        return format_optional_xml(value, tag_name, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::optional<std::vector<int>>>)
    {
        return format_optional_xml(value, tag_name, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::optional<std::vector<std::string>>>)
    {
        return format_optional_xml(value, tag_name, indent_level);
    }

    // Tuples
    else if constexpr (std::is_same_v<T, std::tuple<int, int>>)
    {
        return format_tuple_xml(value, std::index_sequence_for<int, int>{}, tag_name, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::tuple<int, std::string>>)
    {
        return format_tuple_xml(
            value, std::index_sequence_for<int, std::string>{}, tag_name, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::tuple<std::string, int, double>>)
    {
        return format_tuple_xml(
            value, std::index_sequence_for<std::string, int, double>{}, tag_name, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::tuple<int, int, int>>)
    {
        return format_tuple_xml(
            value, std::index_sequence_for<int, int, int>{}, tag_name, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::tuple<std::string, std::string>>)
    {
        return format_tuple_xml(
            value, std::index_sequence_for<std::string, std::string>{}, tag_name, indent_level);
    }

    // Mixed complex types
    else if constexpr (std::is_same_v<T, std::vector<std::tuple<int, std::string>>>)
    {
        return format_vector_xml(value, tag_name, indent_level);
    }
    else if constexpr (std::is_same_v<T, std::tuple<std::vector<int>, std::string>>)
    {
        return format_tuple_xml(value,
                                std::index_sequence_for<std::vector<int>, std::string>{},
                                tag_name,
                                indent_level);
    }

    // Fallback for unknown types
    else
    {
        ss << ind << "<" << tag_name << " type=\"unknown\">" << typeid(T).name() << "</" << tag_name
           << ">";
    }

    return ss.str();
}

// Main serialize function - pretty formatted
template <typename ObjectType>
std::string serialize(const std::vector<ObjectType>& objects, const std::string& root_name = "data")
{
    std::stringstream os;
    os << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
    os << "<" << root_name << ">\n";

    if (objects.empty())
    {
        os << "  <!-- Empty collection -->\n";
        os << "</" << root_name << ">\n";
        return os.str();
    }

    constexpr auto& fields = meta::MetaTuple<ObjectType>::fields;

    for (size_t i = 0; i < objects.size(); ++i)
    {
        const auto& obj = objects[i];
        os << "  <object index=\"" << i << "\">\n";

        std::apply(
            [&](auto&&... fieldMeta) -> void
            {
                ((os << format_xml_value(obj.*(fieldMeta.memberPtr), fieldMeta.memberName, 2)
                     << "\n"),
                 ...);
            },
            fields);

        os << "  </object>\n";
    }

    os << "</" << root_name << ">\n";
    return os.str();
}

// Compact version - attributes where possible
template <typename ObjectType>
std::string serialize_compact(const std::vector<ObjectType>& objects,
                              const std::string& root_name = "data")
{
    std::stringstream os;
    os << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
    os << "<" << root_name << ">\n";

    if (objects.empty())
    {
        os << "</" << root_name << ">\n";
        return os.str();
    }

    constexpr auto& fields = meta::MetaTuple<ObjectType>::fields;

    for (size_t i = 0; i < objects.size(); ++i)
    {
        const auto& obj = objects[i];
        os << "  <object";

        // Try to put simple fields as attributes
        std::apply(
            [&](auto&&... fieldMeta) -> void
            {
                ((std::is_arithmetic_v<typename decltype(fieldMeta)::FieldType> || 
                  std::is_same_v<typename decltype(fieldMeta)::FieldType, std::string>) ?
                 (os << " " << fieldMeta.memberName << "=\"" 
                     << escape_xml_string(std::to_string(obj.*(fieldMeta.memberPtr))) << "\"") :
                 void()), ...);
            },
            fields);

        os << ">\n";

        // Complex fields as child elements
        std::apply(
            [&](auto&&... fieldMeta) -> void
            {
                ((!std::is_arithmetic_v<typename decltype(fieldMeta)::FieldType> && 
                  !std::is_same_v<typename decltype(fieldMeta)::FieldType, std::string>) ?
                 (os << format_xml_value(obj.*(fieldMeta.memberPtr), fieldMeta.memberName, 2) << "\n") :
                 void()), ...);
            },
            fields);

        os << "  </object>\n";
    }

    os << "</" << root_name << ">\n";
    return os.str();
}

// Alternative serialize function with schema information
template <typename ObjectType>
std::string serialize_with_schema(const std::vector<ObjectType>& objects,
                                  const std::string& root_name = "data",
                                  const std::string& schema_location = "")
{
    std::stringstream os;
    os << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";

    if (!schema_location.empty())
    {
        os << "<" << root_name << " xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\""
           << " xsi:schemaLocation=\"" << schema_location << "\">\n";
    }
    else
    {
        os << "<" << root_name << ">\n";
    }

    os << "  <!-- Generated XML with " << objects.size() << " objects -->\n";

    if (objects.empty())
    {
        os << "  <!-- Empty collection -->\n";
        os << "</" << root_name << ">\n";
        return os.str();
    }

    constexpr auto& fields = meta::MetaTuple<ObjectType>::fields;

    // Add schema comment
    os << "  <!-- Object fields: ";
    std::apply(
        [&](auto&&... fieldMeta) -> void
        {
            bool first = true;
            ((os << (first ? "" : ", ") << (first ? (first = false, "") : "")
                 << fieldMeta.memberName),
             ...);
        },
        fields);
    os << " -->\n";

    for (size_t i = 0; i < objects.size(); ++i)
    {
        const auto& obj = objects[i];
        os << "  <object id=\"" << i << "\">\n";

        std::apply(
            [&](auto&&... fieldMeta) -> void
            {
                ((os << format_xml_value(obj.*(fieldMeta.memberPtr), fieldMeta.memberName, 2)
                     << "\n"),
                 ...);
            },
            fields);

        os << "  </object>\n";
    }

    os << "</" << root_name << ">\n";
    return os.str();
}

// Utility function to serialize single object (not in array)
template <typename ObjectType>
std::string serialize_single(const ObjectType& obj, const std::string& root_name = "object")
{
    std::stringstream os;
    os << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
    os << "<" << root_name << ">\n";

    constexpr auto& fields = meta::MetaTuple<ObjectType>::fields;

    std::apply(
        [&](auto&&... fieldMeta) -> void
        {
            ((os << format_xml_value(obj.*(fieldMeta.memberPtr), fieldMeta.memberName, 1) << "\n"),
             ...);
        },
        fields);

    os << "</" << root_name << ">\n";
    return os.str();
}

} // namespace xml
} // namespace meta
