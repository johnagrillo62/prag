import csv
from typing import get_type_hints

class MetaDataClass(type):
    def __new__(cls, name, bases, dct):
        annotations = dct.get('__annotations__', {})

        # Add an __init__ method
        def __init__(self, **kwargs):
            for field, field_type in annotations.items():
                value = kwargs.get(field, None)
                setattr(self, field, value)

        dct['__init__'] = __init__

        # to_csv_row
        def to_csv_row(self):
            return [getattr(self, field) for field in annotations]

        dct['to_csv_row'] = to_csv_row

        # from_csv_row
        @classmethod
        def from_csv_row(cls, row):
            keys = list(annotations.keys())
            casted_values = {}
            for i, key in enumerate(keys):
                val = row[i]
                expected_type = annotations[key]
                # Basic type conversion
                if expected_type == int:
                    val = int(val)
                elif expected_type == float:
                    val = float(val)
                elif expected_type == bool:
                    val = val.lower() in ('true', '1', 'yes')
                else:
                    val = str(val)
                casted_values[key] = val
            return cls(**casted_values)

        dct['from_csv_row'] = from_csv_row

        # to_sql_insert
        def to_sql_insert(self, table_name: str):
            fields = ", ".join(annotations.keys())
            placeholders = ", ".join(["%s"] * len(annotations))
            values = tuple(getattr(self, field) for field in annotations)
            return f"INSERT INTO {table_name} ({fields}) VALUES ({placeholders});", values

        dct['to_sql_insert'] = to_sql_insert

        return super().__new__(cls, name, bases, dct)
