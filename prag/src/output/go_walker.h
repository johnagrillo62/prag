#pragma once
#include <cctype>
#include <sstream>
#include <string>
#include <variant>
#include <vector>

#include "registry_ast_walker.h"

namespace bhw
{
class GoAstWalker : public RegistryAstWalker
{
  public:
    GoAstWalker() : RegistryAstWalker(bhw::Language::Go)
    {
    }

    Language getLang() override
    {
        return bhw::Language::Go;
    }

    std::string walk(bhw::Ast&& ast) override
    {
        srcLang = ast.srcName;

        // Extract nested structs for proper ordering
        for (auto& node : ast.nodes)
        {
            if (std::holds_alternative<Struct>(node))
            {
                auto& s = std::get<Struct>(node);
                extractNestedStructs(s.members);
            }
        }

        return RegistryAstWalker::walk(std::move(ast));
    }

  protected:
    // Generate header
    std::string generateHeader(const bhw::Ast&) override
    {
        std::ostringstream out;
        out << "// Code generated by GoAstWalker\n"
            << "package " << (srcLang.empty() ? "main" : srcLang) << "\n\n"
            << "import (\n"
            << "\t\"time\"\n"
            << ")\n\n";
        return out.str();
    }

    // Map simple types to Go
    std::string generateSimpleType(const SimpleType& type, size_t) override
    {
        switch (type.reifiedType)
        {
        case ReifiedTypeId::Int8:
        case ReifiedTypeId::Int16:
        case ReifiedTypeId::Int32:
        case ReifiedTypeId::Int64:
            return "int";
        case ReifiedTypeId::UInt8:
        case ReifiedTypeId::UInt16:
        case ReifiedTypeId::UInt32:
        case ReifiedTypeId::UInt64:
            return "uint";
        case ReifiedTypeId::Float32:
            return "float32";
        case ReifiedTypeId::Float64:
            return "float64";
        case ReifiedTypeId::Bool:
            return "bool";
        case ReifiedTypeId::String:
            return "string";
        case ReifiedTypeId::Bytes:
            return "[]byte";
        case ReifiedTypeId::DateTime:
            return "time.Time";
        default:
            return "interface{}";
        }
    }

    // Struct open/close
    std::string generateStructOpen(const Struct& s, size_t ind) override
    {
        return indent(ind) + "type " + s.name + " struct {\n";
    }

    std::string generateStructClose(const Struct&, size_t) override
    {
        return "}\n\n";
    }

    std::string generateField(const Field& field, size_t ind) override
    {
        return indent(ind) + field.name + " " + walkType(*field.type, ind) + "\n";
    }

    // Oneof generation (always correct Go)
    std::string generateOneof(const Oneof& oneof, size_t ind) override
    {
        std::ostringstream out;
        std::string ifaceName = capitalize(oneof.name) + "Oneof";

        // Interface at package level
        out << "// Oneof interface\n";
        out << "type " << ifaceName << " interface { is" << ifaceName << "() }\n\n";

        // Variants at package level
        for (const auto& field : oneof.fields)
        {
            std::string variantName = capitalize(oneof.name) + "_" + capitalize(field.name);
            out << "type " << variantName << " struct {\n";
            out << "\tValue " << walkType(*field.type, ind) << "\n";
            out << "}\n\n";
            out << "func (" << variantName << ") is" << ifaceName << "() {}\n\n";
        }

        // Parent struct
        out << "type " << capitalize(oneof.name) << " struct {\n";
        out << "\tValue " << ifaceName << "\n";
        out << "}\n\n";

        return out.str();
    }

    std::string generatePointerType(const PointerType& type, size_t ind) override
    {
        return "*" + walkType(*type.pointee, ind);
    }

    std::string generateStructType(const StructType& type, size_t ind) override
    {
        if (type.value->isAnonymous)
        {
            std::ostringstream out;
            out << "struct {\n";
            for (const auto& member : type.value->members)
            {
                if (std::holds_alternative<Field>(member))
                    out << generateField(std::get<Field>(member), ind + 1);
            }
            out << indent(ind) << "}";
            return out.str();
        }
        return type.value->name;
    }

  private:
    std::string srcLang;

    // Recursively extract nested structs for proper output order
    void extractNestedStructs(std::vector<StructMember>& members)
    {
        for (auto& member : members)
        {
            if (std::holds_alternative<Struct>(member))
            {
                extractNestedStructs(std::get<Struct>(member).members);
            }
        }
    }

    // Capitalize for Go-exported names
    std::string capitalize(const std::string& s)
    {
        if (s.empty())
            return s;
        std::string r = s;
        r[0] = std::toupper(static_cast<unsigned char>(r[0]));
        return r;
    }
};
} // namespace bhw
