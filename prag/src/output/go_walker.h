#pragma once
#include <cctype>
#include <sstream>
#include <string>

#include "ast_walker.h"

namespace bhw
{

class GoAstWalker : public AstWalker
{
  public:
    GoAstWalker() = default;

    Language getLang() override
    {
        return Language::Go;
    }

  protected:
    // ---------------- Header/Footer ----------------
    std::string generateHeader(const Ast& ast) override
    {
        std::ostringstream out;
        out << "// Code generated by GoAstWalker\n";
        out << "package " << (srcLang.empty() ? "main" : srcLang) << "\n\n";
        out << "import (\n\t\"time\"\n)\n\n";
        return out.str();
    }

    std::string generateFooter(const Ast&) override
    {
        return "";
    }

    // ---------------- Struct/Field ----------------
    std::string generateStructOpen(const Struct& s, const WalkContext& ctx) override
    {
        if (ctx.pass == WalkContext::Pass::Flatten)
            return ""; // first pass only emits nested types
        return ctx.indent() + "type " + s.name + " struct {\n";
    }

    std::string generateStructClose(const Struct& s, const WalkContext& ctx) override
    {
        if (ctx.pass == WalkContext::Pass::Flatten)
            return "";
        return ctx.indent() + "}\n\n";
    }

    std::string generateField(const Field& field, const WalkContext& ctx) override
    {
        if (ctx.pass == WalkContext::Pass::Flatten)
        {
            return ""; // Skip fields during flatten pass
        }
        return ctx.indent() + field.name + " " + walkType(*field.type, ctx) + "\n";
    }
  
    // ---------------- Enum ----------------
    std::string generateEnumOpen(const Enum& e, const WalkContext& ctx) override
    {
        if (ctx.pass == WalkContext::Pass::Flatten)
            return ""; // flatten in first pass
        return ctx.indent() + "type " + e.name + " int\nconst (\n";
    }

    std::string generateEnumValue(const EnumValue& v, bool last, const WalkContext& ctx) override
    {
        if (ctx.pass == WalkContext::Pass::Flatten)
            return "";
        std::ostringstream out;
        out << ctx.indent(1) << v.name;
        if (!last)
            out << ",";
        out << "\n";
        return out.str();
    }

    std::string generateEnumClose(const Enum&, const WalkContext& ctx) override
    {
        if (ctx.pass == WalkContext::Pass::Flatten)
            return "";
        return ctx.indent() + ")\n\n";
    }

    // ---------------- Oneof ----------------
    std::string generateOneof(const Oneof& oneof, const WalkContext& ctx) override
    {
        if (ctx.pass == WalkContext::Pass::Flatten)
        {
            // emit types/interfaces
            std::ostringstream out;
            std::string ifaceName = capitalize(oneof.name) + "Oneof";
            out << "// Oneof interface\n";
            out << "type " << ifaceName << " interface { is" << ifaceName << "() }\n\n";

            for (const auto& field : oneof.fields)
            {
                std::string variantName = capitalize(oneof.name) + "_" + capitalize(field.name);
                out << "type " << variantName << " struct {\n";
                out << "\tValue " << walkType(*field.type, ctx) << "\n";
                out << "}\n\n";
                out << "func (" << variantName << ") is" << ifaceName << "() {}\n\n";
            }
            return out.str();
        }
        else
        {
            // emit parent field in struct
            std::ostringstream out;
            std::string ifaceName = capitalize(oneof.name) + "Oneof";
            out << ctx.indent() << capitalize(oneof.name) << " " << ifaceName << "\n";
            return out.str();
        }
    }

    // ---------------- Type mapping ----------------
    std::string generateSimpleType(const SimpleType& type, const WalkContext&) override
    {
        switch (type.reifiedType)
        {
        case ReifiedTypeId::Int8:
        case ReifiedTypeId::Int16:
        case ReifiedTypeId::Int32:
        case ReifiedTypeId::Int64:
            return "int";
        case ReifiedTypeId::UInt8:
        case ReifiedTypeId::UInt16:
        case ReifiedTypeId::UInt32:
        case ReifiedTypeId::UInt64:
            return "uint";
        case ReifiedTypeId::Float32:
            return "float32";
        case ReifiedTypeId::Float64:
            return "float64";
        case ReifiedTypeId::Bool:
            return "bool";
        case ReifiedTypeId::String:
            return "string";
        case ReifiedTypeId::Bytes:
            return "[]byte";
        case ReifiedTypeId::DateTime:
            return "time.Time";
        default:
            return "interface{}";
        }
    }

    std::string generatePointerType(const PointerType& type, const WalkContext& ctx) override
    {
        return "*" + walkType(*type.pointee, ctx);
    }

    std::string generateStructType(const StructType& type, const WalkContext& ctx) override
    {
        if (type.value->isAnonymous)
        {
            std::ostringstream out;
            out << "struct {\n";
            for (const auto& member : type.value->members)
            {
                if (std::holds_alternative<Field>(member))
                    out << generateField(std::get<Field>(member), ctx.nest());
            }
            out << ctx.indent() << "}";
            return out.str();
        }
        return type.value->name;
    }

  private:
    std::string srcLang;

    std::string capitalize(const std::string& s)
    {
        if (s.empty())
            return s;
        std::string r = s;
        r[0] = static_cast<char>(std::toupper(static_cast<unsigned char>(r[0])));
        return r;
    }
};

} // namespace bhw
