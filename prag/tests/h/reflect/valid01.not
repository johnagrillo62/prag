#include "../meta/meta.h"
#include <iostream>
#include <string>
#include <vector>

// ============================================================================
// FIELD COUNTING - SFINAE technique (no Boost needed!)
// ============================================================================

namespace validator {

namespace detail {
struct any_type {
    template <typename T> 
    constexpr operator T();
};

template <typename T, typename... Args>
concept can_be_initialized = requires { T{std::declval<Args>()...}; };

template <typename T>
consteval size_t count_fields() {
    if constexpr (can_be_initialized<T, any_type, any_type, any_type, any_type, any_type, any_type, any_type, any_type, any_type, any_type>)
        return 10;
    else if constexpr (can_be_initialized<T, any_type, any_type, any_type, any_type, any_type, any_type, any_type, any_type, any_type>)
        return 9;
    else if constexpr (can_be_initialized<T, any_type, any_type, any_type, any_type, any_type, any_type, any_type, any_type>)
        return 8;
    else if constexpr (can_be_initialized<T, any_type, any_type, any_type, any_type, any_type, any_type, any_type>)
        return 7;
    else if constexpr (can_be_initialized<T, any_type, any_type, any_type, any_type, any_type, any_type>)
        return 6;
    else if constexpr (can_be_initialized<T, any_type, any_type, any_type, any_type, any_type>)
        return 5;
    else if constexpr (can_be_initialized<T, any_type, any_type, any_type, any_type>)
        return 4;
    else if constexpr (can_be_initialized<T, any_type, any_type, any_type>)
        return 3;
    else if constexpr (can_be_initialized<T, any_type, any_type>)
        return 2;
    else if constexpr (can_be_initialized<T, any_type>)
        return 1;
    else
        return 0;
}
// ============================================================================
// PRETTY_PRINT - Extract actual field names from compiler
// ============================================================================

#include <regex>

namespace detail {
// Get pretty-printed type info which includes field names
template <typename T>
constexpr auto get_pretty_function() {
#if defined(__GNUC__) || defined(__clang__)
    return __PRETTY_FUNCTION__;
#elif defined(_MSC_VER)
    return __FUNCSIG__;
#else
    return "unsupported";
#endif
}

// Parse field names from aggregate initialization in pretty function
template <typename T>
std::vector<std::string> extract_field_names() {
    // Create a dummy instance to trigger aggregate printing
    std::string type_str = typeid(T).name();
    
    // For GCC/Clang, we can use __PRETTY_FUNCTION__ with structured bindings
    // This is a runtime trick - parse debug symbols or use heuristics
    
    // Simple approach: Use structured binding syntax to get names
    // We'll return placeholder names and add a warning
    std::vector<std::string> names;
    constexpr size_t count = field_count<T>;
    
    for (size_t i = 0; i < count; ++i) {
        names.push_back("field_" + std::to_string(i));
    }
    
    return names;
}

// Alternative: Parse from source if available (external tool)
// Or use debug symbols (DWARF, PDB) at runtime
inline std::vector<std::string> parse_field_names_from_source(const std::string& structName) {
    // In a real validator, you'd parse the source file or debug symbols
    // For now, return empty to indicate "not implemented"
    return {};
}

} // namespace detail

template <typename T>
constexpr size_t field_count = detail::count_fields<T>();

// ============================================================================
// VALIDATION RESULT
// ============================================================================

struct ValidationResult {
    bool valid = true;
    std::vector<std::string> errors;
    std::vector<std::string> warnings;
    
    void addError(const std::string& msg) {
        valid = false;
        errors.push_back(msg);
    }
    
    void addWarning(const std::string& msg) {
        warnings.push_back(msg);
    }
    
    void print() const {
        std::cout << "\n========================================\n";
        std::cout << "       METADATA VALIDATION REPORT\n";
        std::cout << "========================================\n\n";
        
        if (valid && errors.empty() && warnings.empty()) {
            std::cout << "SUCCESS: All checks passed!\n";
            std::cout << "  - All struct fields have metadata\n";
            std::cout << "  - No extra fields in metadata\n";
            std::cout << "  - Field counts match perfectly\n";
        } else {
            if (!errors.empty()) {
                std::cout << "ERRORS (" << errors.size() << "):\n";
                for (const auto& err : errors) {
                    std::cout << "  X " << err << "\n";
                }
                std::cout << "\n";
            }
            
            if (!warnings.empty()) {
                std::cout << "WARNINGS (" << warnings.size() << "):\n";
                for (const auto& warn : warnings) {
                    std::cout << "  ! " << warn << "\n";
                }
                std::cout << "\n";
            }
        }
        
        std::cout << "========================================\n\n";
    }
};

// ============================================================================
// EXTRACT METADATA FIELD NAMES
// ============================================================================

template <typename Tuple, std::size_t... Is>
std::vector<std::string> getMetadataFieldNamesImpl(const Tuple& fields, std::index_sequence<Is...>) {
    std::vector<std::string> names;
    ((names.push_back(std::get<Is>(fields).fieldName)), ...);
    return names;
}

template <typename Tuple>
std::vector<std::string> getMetadataFieldNames(const Tuple& fields) {
    constexpr auto size = std::tuple_size_v<Tuple>;
    return getMetadataFieldNamesImpl(fields, std::make_index_sequence<size>{});
}

// ============================================================================
// DYNAMIC FIELD NAME CHECK (using structured bindings + macros)
// ============================================================================

// Macro to capture field names for validation
#define VALIDATE_METADATA(Type, MetadataFields) \
    validator::validateMetadataWithNames<Type>( \
        MetadataFields, \
        #Type, \
        validator::detail::getFieldNamesFromMacro<Type>(#Type) \
    )

namespace detail {
// Helper to parse field names from struct definition at runtime
// In a real implementation, this would parse source or use debug info
template <typename T>
std::vector<std::string> getFieldNamesFromMacro(const char* typeName) {
    // Placeholder - in production you'd:
    // 1. Parse source files
    // 2. Read from debug symbols (DWARF/PDB)
    // 3. Use external metadata generator
    
    std::vector<std::string> names;
    constexpr size_t count = field_count<T>;
    
    for (size_t i = 0; i < count; ++i) {
        names.push_back("field_" + std::to_string(i));
    }
    
    return names;
}
}

// Enhanced validator with field name checking
template <typename T>
ValidationResult validateMetadataWithNames(
    const auto& metadataFields,
    const char* typeName,
    const std::vector<std::string>& structFieldNames
) {
    ValidationResult result;
    
    constexpr std::size_t structFieldCount = field_count<T>;
    constexpr std::size_t metadataFieldCount = std::tuple_size_v<std::remove_cvref_t<decltype(metadataFields)>>;
    
    std::cout << "Validating metadata for: " << typeName << "\n";
    std::cout << "  Struct has: " << structFieldCount << " fields (via SFINAE)\n";
    std::cout << "  Metadata has: " << metadataFieldCount << " field descriptors\n\n";
    
    // Check field count match
    if (structFieldCount != metadataFieldCount) {
        result.addError(
            "Field count mismatch: struct has " + std::to_string(structFieldCount) + 
            " fields, but metadata has " + std::to_string(metadataFieldCount) + " descriptors"
        );
        
        if (structFieldCount > metadataFieldCount) {
            result.addError(
                "Missing " + std::to_string(structFieldCount - metadataFieldCount) + 
                " field(s) in metadata!"
            );
        } else {
            result.addError(
                "Extra " + std::to_string(metadataFieldCount - structFieldCount) + 
                " field(s) in metadata!"
            );
        }
    } else {
        std::cout << "PASS: Field counts match (" << structFieldCount << " fields)\n\n";
    }
    
    // Get metadata field names
    auto metadataNames = getMetadataFieldNames(metadataFields);
    
    std::cout << "Struct fields (detected):\n";
    for (size_t i = 0; i < structFieldNames.size(); ++i) {
        std::cout << "  [" << i << "] " << structFieldNames[i] << "\n";
    }
    std::cout << "\n";
    
    std::cout << "Metadata fields (defined):\n";
    for (size_t i = 0; i < metadataNames.size(); ++i) {
        std::cout << "  [" << i << "] \"" << metadataNames[i] << "\"\n";
    }
    std::cout << "\n";
    
    // Compare names if we have them
    if (!structFieldNames.empty() && structFieldNames[0] != "field_0") {
        std::cout << "Field name comparison:\n";
        for (size_t i = 0; i < std::min(structFieldNames.size(), metadataNames.size()); ++i) {
            if (structFieldNames[i] != metadataNames[i]) {
                result.addWarning(
                    "Field [" + std::to_string(i) + "] name mismatch: " +
                    "struct has '" + structFieldNames[i] + "' but metadata uses '" + 
                    metadataNames[i] + "'"
                );
                std::cout << "  [" << i << "] MISMATCH: '" << structFieldNames[i] 
                         << "' vs '" << metadataNames[i] << "'\n";
            } else {
                std::cout << "  [" << i << "] OK: '" << structFieldNames[i] << "'\n";
            }
        }
    } else {
        result.addWarning(
            "Field names not available - using SFINAE counting only. "
            "For name validation, use a source parser or debug symbols."
        );
    }
    
    return result;
}

} // namespace validator

// ============================================================================
// TEST WITH CAR
// ============================================================================

struct Car {
    std::string maker;
    std::string model;
    unsigned short year;
    bool electric;
    unsigned int howmanymiles;
    std::vector<std::string> features;
    std::unordered_map<std::string, std::string> specs;
};

namespace meta {
namespace Car {
inline const auto fields = std::make_tuple(
    meta::MakeField<&::Car::maker>(
        "maker",
        meta::DefaultValue{std::string{"Unknown"}}
    ),
    meta::MakeField<&::Car::model>(
        "model",
        meta::DefaultValue{std::string{"Base"}}
    ),
    meta::MakeField<&::Car::year>(
        "year",
        meta::DefaultValue{static_cast<unsigned short>(2024)}
    ),
    meta::MakeField<&::Car::electric>(
        "electric",
        meta::DefaultValue{false}
    ),
    meta::MakeField<&::Car::howmanymiles>(
        "howmanymiles",
        meta::DefaultValue{0u}
    ),
    meta::MakeField<&::Car::features>(
        "features",
        meta::DefaultValue{std::vector<std::string>{}}
    ),
    meta::MakeField<&::Car::specs>(
        "specs",
        meta::DefaultValue{std::unordered_map<std::string, std::string>{}}
    )
);
}
}

// ============================================================================
// TEST WITH BROKEN STRUCT (missing field in metadata)
// ============================================================================

struct BrokenCar {
    std::string maker;
    std::string model;
    unsigned short year;
    bool electric;
    // This struct has 4 fields
};

namespace meta {
namespace BrokenCar {
// But metadata only has 3 fields - OOPS!
inline const auto fields = std::make_tuple(
    meta::MakeField<&::BrokenCar::maker>("maker"),
    meta::MakeField<&::BrokenCar::model>("model"),
    meta::MakeField<&::BrokenCar::year>("year")
    // Missing electric field!
);
}
}

int main() {
    std::cout << "\n";
    std::cout << "==========================================\n";
    std::cout << "    METADATA VALIDATION SYSTEM\n";
    std::cout << "  Using SFINAE Field Counting\n";
    std::cout << "  + Optional Field Name Checking\n";
    std::cout << "==========================================\n";
    std::cout << "\n";
    
    // Test 1: Valid metadata (Car) - field count check only
    std::cout << "TEST 1: Valid Car metadata (count check)\n";
    std::cout << "==========================================\n";
    auto result1 = validator::validateMetadataWithNames<Car>(
        meta::Car::fields,
        "Car",
        {"maker", "model", "year", "electric", "howmanymiles", "features", "specs"}
    );
    result1.print();
    
    // Test 2: Broken metadata (BrokenCar)
    std::cout << "TEST 2: Broken Car metadata (missing field)\n";
    std::cout << "==========================================\n";
    auto result2 = validator::validateMetadataWithNames<BrokenCar>(
        meta::BrokenCar::fields,
        "BrokenCar", 
        {"maker", "model", "year", "electric"}
    );
    result2.print();
    
    // Test 3: Name mismatch
    std::cout << "TEST 3: Name mismatch detection\n";
    std::cout << "==========================================\n";
    auto result3 = validator::validateMetadataWithNames<BrokenCar>(
        meta::BrokenCar::fields,
        "BrokenCar",
        {"manufacturer", "model", "year"}  // First field name differs
    );
    result3.print();
    
    std::cout << "==========================================\n";
    std::cout << "VALIDATION FEATURES:\n";
    std::cout << "  [x] SFINAE field counting (compile-time)\n";
    std::cout << "  [x] Count mismatch detection\n";
    std::cout << "  [x] Field name comparison (when available)\n";
    std::cout << "  [ ] Source parsing (external tool needed)\n";
    std::cout << "  [ ] Debug symbol reading (DWARF/PDB)\n";
    std::cout << "\n";
    std::cout << "For production: integrate with build system\n";
    std::cout << "to parse source files or read debug symbols.\n";
    std::cout << "==========================================\n";
    
    return (result1.valid && result2.valid && result3.valid) ? 0 : 1;
}


