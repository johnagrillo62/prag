#pragma once
#include <string>
#include <concepts>
#include <cstdint>
#include <functional>
#include <utility>
#include <array>
#include <string_view>
#include <optional>
#include <vector>
#include <unordered_map>
#include <type_traits>

#include "meta.h"

namespace meta
{

enum Prop : uint8_t
{
    None = 0,
    PrimaryKey = 1 << 0,
    Setter = 1 << 1,
    Getter = 1 << 2,
    Serializable = 1 << 3,
    Hashable = 1 << 4,
    Private = 1 << 5
};

// Enable bitwise OR for convenience
constexpr Prop operator|(Prop a, Prop b)
{
    return static_cast<Prop>(static_cast<uint8_t>(a) | static_cast<uint8_t>(b));
}
constexpr Prop operator&(Prop a, Prop b)
{
    return static_cast<Prop>(static_cast<uint8_t>(a) & static_cast<uint8_t>(b));
}

inline std::string propsToString(Prop props)
{
    std::vector<std::string> flags;

    if (props & Prop::PrimaryKey)
        flags.push_back("PrimaryKey");
    if (props & Prop::Setter)
        flags.push_back("Setter");
    if (props & Prop::Getter)
        flags.push_back("Getter");
    if (props & Prop::Serializable)
        flags.push_back("Serializable");
    if (props & Prop::Hashable)
        flags.push_back("Hashable");
    if (props & Prop::Private)
        flags.push_back("Private");

    if (flags.empty())
        return "None";

    std::string result = "meta::Prop::" + flags[0];
    for (size_t i = 1; i < flags.size(); ++i)
    {
        result += " | meta::Prop::" + flags[i];
    }
    return result;
}

// Define type aliases outside the template
template<typename Class, typename T>
using GetterPtr_t = T (*)(const Class&);

template<typename Class, typename T>
using SetterPtr_t = void (*)(Class&, const T&);

// Dictionary for attributes - flexible key-value store
using Attributes = std::unordered_map<std::string, std::string>;

// Common attribute keys as constexpr
inline constexpr auto CSV_COLUMN = "csv_column";
inline constexpr auto SQL_COLUMN = "sql_column";
inline constexpr auto SRC_NAME   = "src_name";

// Helper to extract type from member pointer
template <typename>
struct member_pointer_traits;

template <typename Class, typename T>
struct member_pointer_traits<T Class::*> {
    using class_type = Class;
    using member_type = T;
};

// Helper: detect if member pointer is accessible
template <typename T, typename U, U T::* MemberPtr> 
struct is_member_accessible
{
  private:
    template <typename X, typename Y>
    static auto test(int) -> decltype(std::declval<X>().*MemberPtr, std::true_type{});

    template <typename, typename> 
    static auto test(...) -> std::false_type;

  public:
    static constexpr bool value = decltype(test<T, U>(0))::value;
};

// Field metadata template - T deduced from member pointer
template <typename Class,
          auto MemberPtr,
          Prop Props = Prop::None,
          auto GetterPtr = nullptr,
          auto SetterPtr = nullptr>
struct Field
{
private:
    static constexpr bool has_member_ptr = (MemberPtr != nullptr);
    static constexpr bool has_getter = (GetterPtr != nullptr);
    
    using DeducedFromMember = typename std::conditional_t<has_member_ptr, member_pointer_traits<decltype(MemberPtr)>, member_pointer_traits<int Class::*>>::member_type;
    
    using DeducedFromGetter = std::remove_cvref_t<typename std::conditional_t<has_getter, std::invoke_result<decltype(GetterPtr), const Class&>, std::type_identity<int>>::type>;
    
public:
    using T = std::conditional_t<has_member_ptr, DeducedFromMember, DeducedFromGetter>;
    using type = T;
    using FieldType = T;
    
    static constexpr Prop properties = Props;
    static constexpr auto memberPtr = MemberPtr;
    static constexpr auto getterPtr = GetterPtr;
    static constexpr auto setterPtr = SetterPtr;
    
    Field(const std::string& field_type, 
          const std::string& field_name,
          Attributes attrs = {})
        : fieldType(field_type),
          fieldName(field_name),
          attributes(std::move(attrs))
    {
    }

    std::string fieldType;
    std::string fieldName;
    std::string cleanName;
    Attributes attributes;

    std::optional<std::string> getAttribute(const std::string& key) const 
    { 
        if (attributes.empty()) {
            return std::nullopt;
        }
        
        auto it = attributes.find(key);
        if (it != attributes.end()) {
            return it->second;
        }
        return std::nullopt;
    }
    
    bool hasAttribute(const std::string& key) const 
    {
        if (attributes.empty()) {
            return false;
        }
        return attributes.find(key) != attributes.end();
    }
    
    bool hasAttributes() const 
    {
        return !attributes.empty();
    }
    
    std::optional<std::string> getCsvColumn() const 
    {
        return getAttribute(CSV_COLUMN);
    }
    
    std::optional<std::string> getSqlColumn() const 
    {
        return getAttribute(SQL_COLUMN);
    }
  
    T get(const Class& obj) const
    {
        if constexpr (has_member_ptr)
        {
            return obj.*memberPtr;
        }
        else if constexpr (has_getter)
        {
            return getterPtr(obj);
        }
        else
        {
            return T{};
        }
    }

    void set(Class& obj, const T& value) const
    {
        if constexpr (has_member_ptr)
        {
            obj.*memberPtr = value;
        }
        else if constexpr (setterPtr != nullptr)
        {
            setterPtr(obj, value);
        }
    }
};

template <typename T> 
struct MetaTuple
{
    static_assert(sizeof(T) == 0, "No metadata tuple defined for this type");
};

} // namespace meta



